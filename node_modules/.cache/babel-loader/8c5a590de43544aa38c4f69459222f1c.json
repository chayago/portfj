{"ast":null,"code":"import _slicedToArray from \"C:\\\\Users\\\\HP ELITEBOOK\\\\Desktop\\\\winXP-master\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/slicedToArray\";\nimport _toConsumableArray from \"C:\\\\Users\\\\HP ELITEBOOK\\\\Desktop\\\\winXP-master\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/toConsumableArray\";\nimport _objectSpread from \"C:\\\\Users\\\\HP ELITEBOOK\\\\Desktop\\\\winXP-master\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/objectSpread\";\nvar _jsxFileName = \"C:\\\\Users\\\\HP ELITEBOOK\\\\Desktop\\\\winXP-master\\\\src\\\\WinXP\\\\apps\\\\Minesweeper\\\\index.js\";\nimport React, { useReducer, useEffect, useState } from 'react';\nimport sampleSize from 'lodash.samplesize';\nimport { Config } from './config';\nimport MinesweeperView from './MinesweeperView'; // state: {\n//   difficulty: 'Beginner' || 'Intermediate' || 'Expert',\n//   status: 'new' || 'started' || 'died' || 'won',\n//   rows: Number,\n//   columns: Number,\n//   mines: Number,\n//   ceils: Array {\n//     state: 'cover' || 'flag' || 'unknown' || 'open' || 'die' || 'misflagged',\n//     minesAround: Number (negative for mine itself),\n//     opening: true || false\n//   }\n// }\n\nfunction getInitState() {\n  var difficulty = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'Beginner';\n  return _objectSpread({\n    difficulty: difficulty,\n    status: 'new'\n  }, genGameConfig(Config[difficulty]));\n}\n\nfunction reducer(state) {\n  var action = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  switch (action.type) {\n    case 'CLEAR_MAP':\n      var difficulty = action.payload || state.difficulty;\n      return getInitState(difficulty);\n\n    case 'START_GAME':\n      var exclude = action.payload;\n      return _objectSpread({}, state, insertMines(_objectSpread({}, Config[state.difficulty], {\n        exclude: exclude\n      }), state.ceils), {\n        status: 'started'\n      });\n\n    case 'OPEN_CEIL':\n      {\n        var indexes = autoCeils(state, action.payload);\n\n        var ceils = _toConsumableArray(state.ceils);\n\n        indexes.forEach(function (i) {\n          var ceil = ceils[i];\n          ceils[i] = _objectSpread({}, ceil, {\n            state: 'open'\n          });\n        });\n        return _objectSpread({}, state, {\n          ceils: ceils\n        });\n      }\n\n    case 'CHANGE_CEIL_STATE':\n      {\n        var index = action.payload;\n\n        var _ceils = _toConsumableArray(state.ceils);\n\n        var ceil = state.ceils[index];\n        var newState;\n\n        switch (ceil.state) {\n          case 'cover':\n            newState = 'flag';\n            break;\n\n          case 'flag':\n            newState = 'unknown';\n            break;\n\n          case 'unknown':\n            newState = 'cover';\n            break;\n\n          default:\n            throw new Error(\"Unknown ceil state \".concat(ceil.state));\n        }\n\n        _ceils[index] = _objectSpread({}, ceil, {\n          state: newState\n        });\n        return _objectSpread({}, state, {\n          ceils: _ceils\n        });\n      }\n\n    case 'GAME_OVER':\n      {\n        var _ceils2 = state.ceils.map(function (ceil) {\n          if (ceil.minesAround < 0 && ceil.state !== 'flag') {\n            return _objectSpread({}, ceil, {\n              state: 'mine'\n            });\n          } else if (ceil.state === 'flag' && ceil.minesAround >= 0) {\n            return _objectSpread({}, ceil, {\n              state: 'misflagged'\n            });\n          } else {\n            return _objectSpread({}, ceil, {\n              opening: false\n            });\n          }\n        });\n\n        _ceils2[action.payload].state = 'die';\n        return _objectSpread({}, state, {\n          status: 'died',\n          ceils: _ceils2\n        });\n      }\n\n    case 'WON':\n      {\n        var _ceils3 = state.ceils.map(function (ceil) {\n          if (ceil.minesAround >= 0) {\n            return _objectSpread({}, ceil, {\n              state: 'open'\n            });\n          } else {\n            return _objectSpread({}, ceil, {\n              state: 'flag'\n            });\n          }\n        });\n\n        return _objectSpread({}, state, {\n          status: 'won',\n          ceils: _ceils3\n        });\n      }\n\n    case 'OPENING_CEIL':\n      {\n        var _ceil = state.ceils[action.payload];\n\n        var _ceils4 = state.ceils.map(function (ceil) {\n          return _objectSpread({}, ceil, {\n            opening: false\n          });\n        });\n\n        _ceils4[action.payload] = _objectSpread({}, _ceil, {\n          opening: true\n        });\n        return _objectSpread({}, state, {\n          ceils: _ceils4\n        });\n      }\n\n    case 'OPENING_CEILS':\n      {\n        var _indexes = getNearIndexes(action.payload, state.rows, state.columns);\n\n        var _ceils5 = state.ceils.map(function (ceil) {\n          return _objectSpread({}, ceil, {\n            opening: false\n          });\n        });\n\n        [].concat(_toConsumableArray(_indexes), [action.payload]).forEach(function (index) {\n          var ceil = _objectSpread({}, _ceils5[index]);\n\n          ceil.opening = true;\n          _ceils5[index] = ceil;\n        });\n        return _objectSpread({}, state, {\n          ceils: _ceils5\n        });\n      }\n\n    default:\n      return state;\n  }\n}\n\nfunction MineSweeper(_ref) {\n  var defaultDifficulty = _ref.defaultDifficulty,\n      onClose = _ref.onClose;\n\n  var _useReducer = useReducer(reducer, getInitState(defaultDifficulty)),\n      _useReducer2 = _slicedToArray(_useReducer, 2),\n      state = _useReducer2[0],\n      dispatch = _useReducer2[1];\n\n  var seconds = useTimer(state.status);\n\n  function changeCeilState(index) {\n    var ceil = state.ceils[index];\n    if (ceil.state === 'open' || ['won', 'died'].includes(state.status)) return;\n    dispatch({\n      type: 'CHANGE_CEIL_STATE',\n      payload: index\n    });\n  }\n\n  function openCeil(index) {\n    switch (state.status) {\n      case 'new':\n        dispatch({\n          type: 'START_GAME',\n          payload: index\n        });\n        dispatch({\n          type: 'OPEN_CEIL',\n          payload: index\n        });\n        break;\n\n      case 'started':\n        var ceil = state.ceils[index];\n\n        if (['flag', 'open'].includes(ceil.state)) {\n          break;\n        } else if (ceil.minesAround < 0) {\n          dispatch({\n            type: 'GAME_OVER',\n            payload: index\n          });\n        } else {\n          dispatch({\n            type: 'OPEN_CEIL',\n            payload: index\n          });\n        }\n\n        break;\n\n      default: // console.log(state.status);\n\n    }\n  }\n\n  function openCeils(index) {\n    var ceil = state.ceils[index];\n    if (ceil.state !== 'open' || ceil.minesAround <= 0 || state.status !== 'started') return;\n    var indexes = getNearIndexes(index, state.rows, state.columns);\n    var nearCeils = indexes.map(function (i) {\n      return state.ceils[i];\n    });\n    if (nearCeils.filter(function (ceil) {\n      return ceil.state === 'flag';\n    }).length !== ceil.minesAround) return;\n    var mineIndex = indexes.find(function (i) {\n      return state.ceils[i].minesAround < 0 && state.ceils[i].state !== 'flag';\n    });\n\n    if (mineIndex) {\n      dispatch({\n        type: 'GAME_OVER',\n        payload: mineIndex\n      });\n    } else {\n      indexes.forEach(function (i) {\n        return dispatch({\n          type: 'OPEN_CEIL',\n          payload: i\n        });\n      });\n    }\n  }\n\n  useEffect(function () {\n    if (state.status === 'started' && checkRemains() === 0) {\n      dispatch({\n        type: 'WON'\n      });\n    }\n  });\n\n  function onReset(difficulty) {\n    dispatch({\n      type: 'CLEAR_MAP',\n      payload: difficulty\n    });\n  }\n\n  function checkRemains() {\n    var safeCeils = state.ceils.filter(function (ceil) {\n      return ceil.state !== 'open';\n    }).filter(function (ceil) {\n      return ceil.minesAround >= 0;\n    });\n    return safeCeils.length;\n  }\n\n  function openingCeil(index) {\n    if (['died', 'won'].includes(state.status)) return;\n    dispatch({\n      type: 'OPENING_CEIL',\n      payload: index\n    });\n  }\n\n  function openingCeils(index) {\n    if (['died', 'won'].includes(state.status)) return;\n    dispatch({\n      type: 'OPENING_CEILS',\n      payload: index\n    });\n  }\n\n  return React.createElement(MinesweeperView, Object.assign({}, state, {\n    onClose: onClose,\n    changeCeilState: changeCeilState,\n    openCeil: openCeil,\n    openCeils: openCeils,\n    onReset: onReset,\n    seconds: seconds,\n    openingCeil: openingCeil,\n    openingCeils: openingCeils,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 233\n    },\n    __self: this\n  }));\n}\n\nfunction genGameConfig(config) {\n  var rows = config.rows,\n      columns = config.columns,\n      mines = config.mines;\n  var ceils = Array(rows * columns).fill().map(function (_) {\n    return {\n      state: 'cover',\n      minesAround: 0,\n      opening: false\n    };\n  });\n  return {\n    rows: rows,\n    columns: columns,\n    ceils: ceils,\n    mines: mines\n  };\n}\n\nfunction insertMines(config, originCeils) {\n  var rows = config.rows,\n      columns = config.columns,\n      mines = config.mines,\n      exclude = config.exclude;\n  var ceils = originCeils.map(function (ceil) {\n    return _objectSpread({}, ceil);\n  });\n  if (rows * columns !== ceils.length) throw new Error('rows and columns not equal to ceils');\n\n  var indexArray = _toConsumableArray(Array(rows * columns).keys());\n\n  sampleSize(indexArray.filter(function (i) {\n    return i !== exclude;\n  }), mines).forEach(function (chosen) {\n    ceils[chosen].minesAround = -10;\n    getNearIndexes(chosen, rows, columns).forEach(function (nearIndex) {\n      ceils[nearIndex].minesAround += 1;\n    });\n  });\n  return {\n    rows: rows,\n    columns: columns,\n    ceils: ceils,\n    mines: mines\n  };\n}\n\nfunction autoCeils(state, index) {\n  var rows = state.rows,\n      columns = state.columns;\n  var ceils = state.ceils.map(function (ceil) {\n    return _objectSpread({}, ceil, {\n      walked: false\n    });\n  });\n  return walkCeils(index);\n\n  function walkCeils(index) {\n    var ceil = ceils[index];\n    if (ceil.walked || ceil.minesAround < 0 || ceil.state === 'flag') return [];\n    ceil.walked = true;\n    if (ceil.minesAround > 0) return [index];\n    return [index].concat(_toConsumableArray(getNearIndexes(index, rows, columns).reduce(function (lastIndexes, ceilIndex) {\n      return [].concat(_toConsumableArray(lastIndexes), _toConsumableArray(walkCeils(ceilIndex)));\n    }, [])));\n  }\n}\n\nfunction getNearIndexes(index, rows, columns) {\n  if (index < 0 || index >= rows * columns) return [];\n  var row = Math.floor(index / columns);\n  var column = index % columns;\n  return [index - columns - 1, index - columns, index - columns + 1, index - 1, index + 1, index + columns - 1, index + columns, index + columns + 1].filter(function (_, arrayIndex) {\n    if (row === 0 && arrayIndex < 3) return false;\n    if (row === rows - 1 && arrayIndex > 4) return false;\n    if (column === 0 && [0, 3, 5].includes(arrayIndex)) return false;\n    if (column === columns - 1 && [2, 4, 7].includes(arrayIndex)) return false;\n    return true;\n  });\n}\n\nfunction useTimer(status) {\n  var _useState = useState(0),\n      _useState2 = _slicedToArray(_useState, 2),\n      seconds = _useState2[0],\n      setSeconds = _useState2[1];\n\n  function addSecond() {\n    setSeconds(function (sec) {\n      return sec + 1;\n    });\n  }\n\n  useEffect(function () {\n    var timer;\n\n    switch (status) {\n      case 'started':\n        timer = setInterval(addSecond, 1000);\n        break;\n\n      case 'new':\n        setSeconds(0);\n        break;\n\n      default:\n        break;\n    }\n\n    return function () {\n      return clearInterval(timer);\n    };\n  }, [status]);\n  return seconds;\n}\n\nexport default MineSweeper;","map":{"version":3,"sources":["C:\\Users\\HP ELITEBOOK\\Desktop\\winXP-master\\src\\WinXP\\apps\\Minesweeper\\index.js"],"names":["React","useReducer","useEffect","useState","sampleSize","Config","MinesweeperView","getInitState","difficulty","status","genGameConfig","reducer","state","action","type","payload","exclude","insertMines","ceils","indexes","autoCeils","forEach","i","ceil","index","newState","Error","map","minesAround","opening","getNearIndexes","rows","columns","MineSweeper","defaultDifficulty","onClose","dispatch","seconds","useTimer","changeCeilState","includes","openCeil","openCeils","nearCeils","filter","length","mineIndex","find","checkRemains","onReset","safeCeils","openingCeil","openingCeils","config","mines","Array","fill","_","originCeils","indexArray","keys","chosen","nearIndex","walked","walkCeils","reduce","lastIndexes","ceilIndex","row","Math","floor","column","arrayIndex","setSeconds","addSecond","sec","timer","setInterval","clearInterval"],"mappings":"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","sourcesContent":["import React, { useReducer, useEffect, useState } from 'react';\nimport sampleSize from 'lodash.samplesize';\n\nimport { Config } from './config';\nimport MinesweeperView from './MinesweeperView';\n\n// state: {\n//   difficulty: 'Beginner' || 'Intermediate' || 'Expert',\n//   status: 'new' || 'started' || 'died' || 'won',\n//   rows: Number,\n//   columns: Number,\n//   mines: Number,\n//   ceils: Array {\n//     state: 'cover' || 'flag' || 'unknown' || 'open' || 'die' || 'misflagged',\n//     minesAround: Number (negative for mine itself),\n//     opening: true || false\n//   }\n// }\n\nfunction getInitState(difficulty = 'Beginner') {\n  return {\n    difficulty,\n    status: 'new',\n    ...genGameConfig(Config[difficulty]),\n  };\n}\n\nfunction reducer(state, action = {}) {\n  switch (action.type) {\n    case 'CLEAR_MAP':\n      const difficulty = action.payload || state.difficulty;\n      return getInitState(difficulty);\n    case 'START_GAME':\n      const exclude = action.payload;\n      return {\n        ...state,\n        ...insertMines({ ...Config[state.difficulty], exclude }, state.ceils),\n        status: 'started',\n      };\n    case 'OPEN_CEIL': {\n      const indexes = autoCeils(state, action.payload);\n      const ceils = [...state.ceils];\n      indexes.forEach(i => {\n        const ceil = ceils[i];\n        ceils[i] = { ...ceil, state: 'open' };\n      });\n      return {\n        ...state,\n        ceils,\n      };\n    }\n    case 'CHANGE_CEIL_STATE': {\n      const index = action.payload;\n      const ceils = [...state.ceils];\n      const ceil = state.ceils[index];\n      let newState;\n      switch (ceil.state) {\n        case 'cover':\n          newState = 'flag';\n          break;\n        case 'flag':\n          newState = 'unknown';\n          break;\n        case 'unknown':\n          newState = 'cover';\n          break;\n        default:\n          throw new Error(`Unknown ceil state ${ceil.state}`);\n      }\n      ceils[index] = { ...ceil, state: newState };\n      return {\n        ...state,\n        ceils,\n      };\n    }\n    case 'GAME_OVER': {\n      const ceils = state.ceils.map(ceil => {\n        if (ceil.minesAround < 0 && ceil.state !== 'flag') {\n          return {\n            ...ceil,\n            state: 'mine',\n          };\n        } else if (ceil.state === 'flag' && ceil.minesAround >= 0) {\n          return {\n            ...ceil,\n            state: 'misflagged',\n          };\n        } else {\n          return {\n            ...ceil,\n            opening: false,\n          };\n        }\n      });\n      ceils[action.payload].state = 'die';\n      return {\n        ...state,\n        status: 'died',\n        ceils,\n      };\n    }\n    case 'WON': {\n      const ceils = state.ceils.map(ceil => {\n        if (ceil.minesAround >= 0) {\n          return {\n            ...ceil,\n            state: 'open',\n          };\n        } else {\n          return {\n            ...ceil,\n            state: 'flag',\n          };\n        }\n      });\n      return {\n        ...state,\n        status: 'won',\n        ceils,\n      };\n    }\n    case 'OPENING_CEIL': {\n      const ceil = state.ceils[action.payload];\n      const ceils = state.ceils.map(ceil => ({\n        ...ceil,\n        opening: false,\n      }));\n      ceils[action.payload] = { ...ceil, opening: true };\n      return {\n        ...state,\n        ceils,\n      };\n    }\n    case 'OPENING_CEILS': {\n      const indexes = getNearIndexes(action.payload, state.rows, state.columns);\n      const ceils = state.ceils.map(ceil => ({\n        ...ceil,\n        opening: false,\n      }));\n      [...indexes, action.payload].forEach(index => {\n        const ceil = { ...ceils[index] };\n        ceil.opening = true;\n        ceils[index] = ceil;\n      });\n      return {\n        ...state,\n        ceils,\n      };\n    }\n    default:\n      return state;\n  }\n}\n\nfunction MineSweeper({ defaultDifficulty, onClose }) {\n  const [state, dispatch] = useReducer(\n    reducer,\n    getInitState(defaultDifficulty),\n  );\n  const seconds = useTimer(state.status);\n  function changeCeilState(index) {\n    const ceil = state.ceils[index];\n    if (ceil.state === 'open' || ['won', 'died'].includes(state.status)) return;\n    dispatch({ type: 'CHANGE_CEIL_STATE', payload: index });\n  }\n  function openCeil(index) {\n    switch (state.status) {\n      case 'new':\n        dispatch({ type: 'START_GAME', payload: index });\n        dispatch({ type: 'OPEN_CEIL', payload: index });\n        break;\n      case 'started':\n        const ceil = state.ceils[index];\n        if (['flag', 'open'].includes(ceil.state)) {\n          break;\n        } else if (ceil.minesAround < 0) {\n          dispatch({ type: 'GAME_OVER', payload: index });\n        } else {\n          dispatch({ type: 'OPEN_CEIL', payload: index });\n        }\n        break;\n      default:\n        // console.log(state.status);\n    }\n  }\n  function openCeils(index) {\n    const ceil = state.ceils[index];\n    if (\n      ceil.state !== 'open' ||\n      ceil.minesAround <= 0 ||\n      state.status !== 'started'\n    )\n      return;\n    const indexes = getNearIndexes(index, state.rows, state.columns);\n    const nearCeils = indexes.map(i => state.ceils[i]);\n    if (\n      nearCeils.filter(ceil => ceil.state === 'flag').length !==\n      ceil.minesAround\n    )\n      return;\n    const mineIndex = indexes.find(\n      i => state.ceils[i].minesAround < 0 && state.ceils[i].state !== 'flag',\n    );\n    if (mineIndex) {\n      dispatch({ type: 'GAME_OVER', payload: mineIndex });\n    } else {\n      indexes.forEach(i => dispatch({ type: 'OPEN_CEIL', payload: i }));\n    }\n  }\n  useEffect(() => {\n    if (state.status === 'started' && checkRemains() === 0) {\n      dispatch({ type: 'WON' });\n    }\n  });\n  function onReset(difficulty) {\n    dispatch({ type: 'CLEAR_MAP', payload: difficulty });\n  }\n  function checkRemains() {\n    const safeCeils = state.ceils\n      .filter(ceil => ceil.state !== 'open')\n      .filter(ceil => ceil.minesAround >= 0);\n    return safeCeils.length;\n  }\n  function openingCeil(index) {\n    if (['died', 'won'].includes(state.status)) return;\n    dispatch({ type: 'OPENING_CEIL', payload: index });\n  }\n  function openingCeils(index) {\n    if (['died', 'won'].includes(state.status)) return;\n    dispatch({ type: 'OPENING_CEILS', payload: index });\n  }\n  return (\n    <MinesweeperView\n      {...state}\n      onClose={onClose}\n      changeCeilState={changeCeilState}\n      openCeil={openCeil}\n      openCeils={openCeils}\n      onReset={onReset}\n      seconds={seconds}\n      openingCeil={openingCeil}\n      openingCeils={openingCeils}\n    />\n  );\n}\n\nfunction genGameConfig(config) {\n  const { rows, columns, mines } = config;\n  const ceils = Array(rows * columns)\n    .fill()\n    .map(_ => ({\n      state: 'cover',\n      minesAround: 0,\n      opening: false,\n    }));\n  return {\n    rows,\n    columns,\n    ceils,\n    mines,\n  };\n}\n\nfunction insertMines(config, originCeils) {\n  const { rows, columns, mines, exclude } = config;\n  const ceils = originCeils.map(ceil => ({ ...ceil }));\n  if (rows * columns !== ceils.length)\n    throw new Error('rows and columns not equal to ceils');\n  const indexArray = [...Array(rows * columns).keys()];\n  sampleSize(indexArray.filter(i => i !== exclude), mines).forEach(chosen => {\n    ceils[chosen].minesAround = -10;\n    getNearIndexes(chosen, rows, columns).forEach(nearIndex => {\n      ceils[nearIndex].minesAround += 1;\n    });\n  });\n  return {\n    rows,\n    columns,\n    ceils,\n    mines,\n  };\n}\n\nfunction autoCeils(state, index) {\n  const { rows, columns } = state;\n  const ceils = state.ceils.map(ceil => ({\n    ...ceil,\n    walked: false,\n  }));\n  return walkCeils(index);\n  function walkCeils(index) {\n    const ceil = ceils[index];\n    if (ceil.walked || ceil.minesAround < 0 || ceil.state === 'flag') return [];\n    ceil.walked = true;\n    if (ceil.minesAround > 0) return [index];\n    return [\n      index,\n      ...getNearIndexes(index, rows, columns).reduce(\n        (lastIndexes, ceilIndex) => {\n          return [...lastIndexes, ...walkCeils(ceilIndex)];\n        },\n        [],\n      ),\n    ];\n  }\n}\n\nfunction getNearIndexes(index, rows, columns) {\n  if (index < 0 || index >= rows * columns) return [];\n  const row = Math.floor(index / columns);\n  const column = index % columns;\n  return [\n    index - columns - 1,\n    index - columns,\n    index - columns + 1,\n    index - 1,\n    index + 1,\n    index + columns - 1,\n    index + columns,\n    index + columns + 1,\n  ].filter((_, arrayIndex) => {\n    if (row === 0 && arrayIndex < 3) return false;\n    if (row === rows - 1 && arrayIndex > 4) return false;\n    if (column === 0 && [0, 3, 5].includes(arrayIndex)) return false;\n    if (column === columns - 1 && [2, 4, 7].includes(arrayIndex)) return false;\n    return true;\n  });\n}\n\nfunction useTimer(status) {\n  const [seconds, setSeconds] = useState(0);\n  function addSecond() {\n    setSeconds(sec => sec + 1);\n  }\n  useEffect(() => {\n    let timer;\n    switch (status) {\n      case 'started':\n        timer = setInterval(addSecond, 1000);\n        break;\n      case 'new':\n        setSeconds(0);\n        break;\n      default:\n        break;\n    }\n    return () => clearInterval(timer);\n  }, [status]);\n  return seconds;\n}\n\nexport default MineSweeper;\n"]},"metadata":{},"sourceType":"module"}